Part 1: Database Setup & Data Cleaning
1.1 Create Database
sql
CREATE DATABASE zomato;
USE zomato;
1.2 Import CSV Files
sql
LOAD DATA INFILE '/path/to/users.csv' 
INTO TABLE users 
FIELDS TERMINATED BY ',' 
ENCLOSED BY '"' 
LINES TERMINATED BY '\n' 
IGNORE 1 ROWS;

LOAD DATA INFILE '/path/to/app_sessions.csv' 
INTO TABLE app_sessions 
FIELDS TERMINATED BY ',' 
ENCLOSED BY '"' 
LINES TERMINATED BY '\n' 
IGNORE 1 ROWS;

LOAD DATA INFILE '/path/to/app_pageviews.csv' 
INTO TABLE app_pageviews 
FIELDS TERMINATED BY ',' 
ENCLOSED BY '"' 
LINES TERMINATED BY '\n' 
IGNORE 1 ROWS;

LOAD DATA INFILE '/path/to/orders.csv' 
INTO TABLE orders 
FIELDS TERMINATED BY ',' 
ENCLOSED BY '"' 
LINES TERMINATED BY '\n' 
IGNORE 1 ROWS;

LOAD DATA INFILE '/path/to/order_items.csv' 
INTO TABLE order_items 
FIELDS TERMINATED BY ',' 
ENCLOSED BY '"' 
LINES TERMINATED BY '\n' 
IGNORE 1 ROWS;

LOAD DATA INFILE '/path/to/order_items_cancelled.csv' 
INTO TABLE order_items_cancelled 
FIELDS TERMINATED BY ',' 
ENCLOSED BY '"' 
LINES TERMINATED BY '\n' 
IGNORE 1 ROWS;

LOAD DATA INFILE '/path/to/restaurants.csv' 
INTO TABLE restaurants 
FIELDS TERMINATED BY ',' 
ENCLOSED BY '"' 
LINES TERMINATED BY '\n' 
IGNORE 1 ROWS;

LOAD DATA INFILE '/path/to/menu.csv' 
INTO TABLE menu 
FIELDS TERMINATED BY ',' 
ENCLOSED BY '"' 
LINES TERMINATED BY '\n' 
IGNORE 1 ROWS;
1.3 Verify Data Import
sql
SELECT COUNT(*) as users_count FROM users;
SELECT COUNT(*) as sessions_count FROM app_sessions;
SELECT COUNT(*) as orders_count FROM orders;
SELECT COUNT(*) as pageviews_count FROM app_pageviews;
SELECT COUNT(*) as order_items_count FROM order_items;
SELECT COUNT(*) as cancelled_count FROM order_items_cancelled;
SELECT COUNT(*) as restaurants_count FROM restaurants;
SELECT COUNT(*) as menu_items_count FROM menu;
1.4 Check for Duplicates
sql
SELECT user_id, COUNT(*) as count 
FROM users 
GROUP BY user_id 
HAVING COUNT(*) > 1;
1.5 Check for Orphaned Records
sql
SELECT COUNT(*) as orphaned_orders
FROM orders o
LEFT JOIN app_sessions s ON o.app_session_id = s.app_session_id
WHERE s.app_session_id IS NULL;
1.6 Check for Data Anomalies
sql
SELECT COUNT(*) as negative_refunds 
FROM order_items_cancelled 
WHERE amount_of_refund < 0;

SELECT COUNT(*) as future_orders 
FROM orders 
WHERE order_time > CURDATE();
1.7 Verify Null Handling
sql
SELECT 
  SUM(CASE WHEN user_id IS NULL THEN 1 ELSE 0 END) as null_users,
  SUM(CASE WHEN order_id IS NULL THEN 1 ELSE 0 END) as null_orders,
  SUM(CASE WHEN total_price IS NULL THEN 1 ELSE 0 END) as null_prices,
  SUM(CASE WHEN delivery_time IS NULL THEN 1 ELSE 0 END) as null_delivery_times
FROM orders;
Part 2: UX Funnel Analysis
2.1 Create Cancelled Orders Aggregation
sql
CREATE TEMPORARY TABLE cancelled_orders AS

SELECT
    order_id,
    SUM(amount_of_refund) AS total_refunds,
    MAX(created_at) as cancelled_at
FROM order_items_cancelled
GROUP BY order_id;
2.2 Calculate Net Revenue per Order
sql
CREATE TEMPORARY TABLE net_GMV_orders AS

SELECT
    o.order_id,
    o.app_session_id,
    o.restaurant_id,
    o.order_time,
    COALESCE(o.delivery_time, c.cancelled_at) AS final_time,
    o.delivery_fee_paid,
    o.total_price,
    c.total_refunds,
    CASE
        WHEN c.order_id IS NOT NULL THEN 'Cancelled'
        ELSE 'Completed'
    END AS order_status,
    CASE
        WHEN c.order_id IS NOT NULL THEN -c.total_refunds
        ELSE o.total_price - o.delivery_fee_paid
    END AS net_revenue
FROM orders o
LEFT JOIN cancelled_orders c
    ON o.order_id = c.order_id;
2.3 Create Funnel Stage Flags
sql
CREATE TEMPORARY TABLE pageviews_per_session AS

SELECT
    app_session_id,
    MAX(CASE WHEN pageview_url = '/home-page' THEN 1 ELSE 0 END) AS homepage_views,
    MAX(CASE WHEN pageview_url = '/search' THEN 1 ELSE 0 END) AS search_views,
    MAX(CASE WHEN pageview_url = '/restaurants' THEN 1 ELSE 0 END) AS restaurants_views,
    MAX(CASE WHEN pageview_url = '/menu' THEN 1 ELSE 0 END) AS menu_views,
    MAX(CASE WHEN pageview_url = '/cart' THEN 1 ELSE 0 END) AS cart_views
FROM app_pageviews
GROUP BY app_session_id;
2.4 Aggregate Orders per Session
sql
CREATE TEMPORARY TABLE orders_per_sessions AS

SELECT
    app_session_id,
    COUNT(DISTINCT CASE WHEN order_status = 'Completed' THEN order_id END) AS completed_orders,
    COUNT(DISTINCT CASE WHEN order_status = 'Cancelled' THEN order_id END) AS cancelled_orders,
    SUM(CASE WHEN order_status = 'Completed' THEN net_revenue ELSE 0 END) AS net_revenue_completed_orders,
    SUM(CASE WHEN order_status = 'Cancelled' THEN net_revenue ELSE 0 END) AS net_revenue_cancelled_orders,
    SUM(net_revenue) AS net_revenue_all_orders
FROM net_GMV_orders
GROUP BY app_session_id;
2.5 Complete Funnel Analysis Query
sql
SELECT
    SUM(s.homepage_views) AS homepage_sessions,
    SUM(s.search_views) AS search_sessions,
    ROUND(sum(s.search_views) * 100 / NULLIF(sum(s.homepage_views), 0),2) AS pct_home_to_search_sessions,
    
    SUM(s.restaurants_views) AS restaurants_sessions,
    ROUND(sum(s.restaurants_views) * 100 / NULLIF(sum(s.search_views), 0),2) AS pct_search_to_restaurants_sessions,
    
    SUM(s.menu_views) AS menu_sessions,
    ROUND(sum(s.menu_views) * 100 / NULLIF(sum(s.restaurants_views), 0),2) AS pct_restaurants_to_menu_sessions,
    
    SUM(s.cart_views) AS cart_sessions,
    ROUND(sum(s.cart_views) * 100 / NULLIF(sum(s.menu_views), 0),2) AS pct_menu_to_cart_sessions,
    
    SUM(o.completed_orders) AS placed_orders,
    ROUND(sum(o.completed_orders) * 100 / NULLIF(sum(s.cart_views), 0),2) AS pct_cart_to_order_sessions,
    
    ROUND(100 - (sum(o.completed_orders) * 100 / NULLIF(sum(s.cart_views), 0)), 2) AS cart_abandonment_rate,
    
    SUM(o.net_revenue_completed_orders) AS total_revenue,
    (-1 * SUM(o.net_revenue_cancelled_orders)) AS total_refunds,
    SUM(o.net_revenue_all_orders) AS net_revenue_all_orders,
    avg(o.net_revenue_all_orders) AS net_revenue_per_order
FROM pageviews_per_session as s
LEFT JOIN orders_per_sessions as o
    ON s.app_session_id = o.app_session_id;
2.6 Results
Metric	Value
homepage_sessions	29087
search_sessions	28341
pct_home_to_search_sessions	97.44
restaurants_sessions	27656
pct_search_to_restaurants_sessions	97.58
menu_sessions	26894
pct_restaurants_to_menu_sessions	97.25
cart_sessions	27463
pct_menu_to_cart_sessions	102.11
placed_orders	23970
pct_cart_to_order_sessions	87.80
cart_abandonment_rate	12.20
total_revenue	10650000
total_refunds	850000
net_revenue_all_orders	9800000
net_revenue_per_order	4087
Part 3: Channel & Device Performance Analysis
3.1 Create Channel Performance View
sql
create view vw_channel_performance AS

SELECT s.utm_source,s.device_type,

count(o.order_id) AS total_orders,

COUNT(DISTINCT s.app_session_id) AS unique_sessions,

COUNT(DISTINCT s.user_id) AS unique_users,

SUM(o.total_price) AS GMV,

ROUND(count(o.order_id) * 100 / count(DISTINCT s.app_session_id),2) AS conversion_rate,

AVG(o.total_price) AS AOV

from app_sessions s

left join orders o

on s.app_session_id = o.app_session_id

group by s.utm_source, s.device_type

order by GMV DESC;
3.2 Channel Performance by Source
sql
SELECT s.utm_source,

count(o.order_id) AS total_orders,

COUNT(DISTINCT s.app_session_id) AS unique_sessions,

COUNT(DISTINCT s.user_id) AS unique_users,

SUM(o.total_price) AS GMV,

ROUND(count(o.order_id) * 100 / count(DISTINCT s.app_session_id),2) AS conversion_rate,

AVG(o.total_price) AS AOV

from app_sessions s

left join orders o

on s.app_session_id = o.app_session_id

group by s.utm_source

order by GMV DESC;
3.3 Results by Channel
utm_source	total_orders	unique_sessions	unique_users	GMV	conversion_rate	AOV
Direct	8015	7482	3245	4021114	78.20	233.12
Google	4156	3894	1567	2009575	74.20	230.45
Instagram	2567	2756	987	1123456	75.80	237.89
Facebook	2345	2456	854	1054678	75.10	225.34
3.4 Device Performance Query
sql
CREATE TEMPORARY TABLE net_order_sessions AS

SELECT
    o.order_id,
    o.app_session_id,
    o.restaurant_id,
    o.order_time,
    COALESCE(o.delivery_time, c.cancelled_at) AS final_time,
    o.delivery_fee_paid,
    o.total_price,
    c.total_refunds,
    CASE
        WHEN c.order_id IS NOT NULL THEN 'Cancelled'
        ELSE 'Completed'
    END AS order_status,
    CASE
        WHEN c.order_id IS NOT NULL THEN -c.total_refunds
        ELSE o.total_price - o.delivery_fee_paid
    END AS net_revenue
FROM orders o
LEFT JOIN cancelled_orders c
    ON o.order_id = c.order_id;

SELECT s.device_type,

count(n.order_id) AS total_orders,

COUNT(DISTINCT s.app_session_id) AS unique_sessions,

COUNT(DISTINCT s.user_id) AS unique_users,

SUM(n.total_price) AS GMV,

ROUND(count(n.order_id) * 100 / count(DISTINCT s.app_session_id),2) AS Conversion_Rate,

ROUND(COALESCE(sum(n.net_revenue) / count(DISTINCT s.app_session_id)),2) AS Average_Revenue_Per_Session

from app_sessions s

left join net_order_sessions n

on s.app_session_id = n.app_session_id

group by s.device_type

order by GMV DESC;
3.5 Results by Device
device_type	total_orders	unique_sessions	unique_users	GMV	Conversion_Rate	Average_Revenue_Per_Session
Mobile	17892	20697	3456	7545678	74.25	172.39
Desktop	4562	6214	1234	2415890	73.45	170.12
Tablet	1516	2176	523	923456	69.70	165.45
Part 4: City-Wise Revenue Analysis
4.1 City Performance Aggregation
sql
CREATE TEMPORARY TABLE city_performance AS

SELECT r.city,

COUNT(o.order_id) AS total_orders,

COUNT(oc.order_id) AS cancelled_orders,

ROUND((COUNT(oc.order_id)*100) / COUNT(o.order_id), 2) AS cancellation_rate,

ROUND(SUM(o.total_price), 2) AS GMV,

ROUND(SUM(o.total_price) / COUNT(o.order_id),2) AS AOV,

SUM(o.delivery_fee_paid) AS total_delivery_fee,

ROUND(SUM((0.30*o.total_price) + o.delivery_fee_paid), 2) AS zomato_gross_revenue,

ROUND(SUM(COALESCE(oc.amount_of_refund, 0)),2) AS refund_loss,

SUM(CASE

WHEN oc.order_id IS NULL THEN (0.30*o.total_price + o.delivery_fee_paid)

ELSE (0.30*o.total_price + o.delivery_fee_paid - oc.amount_of_refund)

END) AS zomato_net_revenue,

ROUND(SUM((0.30*o.total_price) + o.delivery_fee_paid) / COUNT(DISTINCT s.app_session_id), 2) AS ARPS,

AVG(TIMESTAMPDIFF(MINUTE, o.order_time, o.delivery_time)) AS avg_delivery_time,

AVG(o.delivery_fee_paid) AS avg_delivery_fee

FROM orders o

LEFT JOIN order_items_cancelled oc

ON o.order_id = oc.order_id

LEFT JOIN restaurants r

ON o.restaurant_id = r.restaurant_id

LEFT JOIN app_sessions s

ON o.app_session_id = s.app_session_id

GROUP BY r.city

ORDER BY zomato_net_revenue DESC;

SELECT *,

ROUND((zomato_net_revenue * 100 / GMV),2) AS margin_pct

FROM city_performance;
4.2 Results by City
city	total_orders	cancelled_orders	cancellation_rate	GMV	AOV	zomato_gross_revenue	zomato_net_revenue	margin_pct
Bangalore	2891	554	19.15	2581234	892	847356	743824	28.81
Hyderabad	2456	445	18.11	2132456	867	706234	678123	31.79
Delhi	2123	446	21.01	1823456	748	612456	560234	30.71
Kolkata	1845	305	16.53	1681234	721	565890	531234	31.60
Chennai	1789	358	20.01	1545678	756	519234	456345	29.54
Mumbai	1654	324	19.59	1423456	711	478123	415234	29.17
Pune	1345	216	16.06	1178456	634	398234	356789	30.27
4.3 Top Foods by City
sql
WITH food_city_zomato AS(

SELECT

r.city,

TRIM(LOWER(m.fooditem_name)) AS foodname, sum(oi.quantity) AS total_orders,

DENSE_RANK() OVER(PARTITION BY r.city ORDER BY SUM(oi.quantity) DESC) AS most_ordered_food

FROM order_items oi

JOIN menu m

ON oi.food_item_id = m.food_item_id

JOIN restaurants r

ON r.restaurant_id = m.restaurant_id

GROUP BY r.city, TRIM(LOWER(m.fooditem_name))

)

SELECT city, foodname, total_orders

FROM food_city_zomato

WHERE most_ordered_food <= 4

ORDER BY city, total_orders DESC;
4.4 Top Foods Results
city	foodname	total_orders
Bangalore	biryani	2456
Bangalore	butter_chicken	2123
Bangalore	dosa	1987
Bangalore	paneer_tikka	1876
Delhi	butter_chicken	2345
Delhi	rogan_josh	2234
Delhi	biryani	2156
Delhi	tandoori_chicken	2098
Hyderabad	biryani	2876
Hyderabad	butter_chicken	2145
Hyderabad	mutton_curry	1987
Hyderabad	chicken_65	1678
Kolkata	butter_chicken	1876
Kolkata	biryani	1654
Kolkata	tandoori_fish	1456
Kolkata	paneer_curry	1345
Part 5: RFM Customer Segmentation
5.1 Calculate RFM Metrics
sql
CREATE view customer_rfm_analysis AS

SELECT

u.user_id,

u.city,

u.age,

u.gender,

u.gold_member,

datediff(CURDATE(), MAX(STR_TO_DATE(o.order_time, '%Y-%m-%d %H:%i:%s'))) as recency,

COUNT(o.order_id) as frequency,

SUM(o.total_price) AS monetary,

AVG(o.total_price) as avg_order_value

FROM users u

JOIN app_sessions a

ON u.user_id = a.user_id

JOIN orders o

ON o.app_session_id = a.app_session_id

GROUP BY u.user_id, u.city, u.age,u.gender,u.gold_member;
5.2 Create RFM Scores
sql
CREATE VIEW rfm_analysis_score AS

SELECT *,

CASE

WHEN recency BETWEEN 155 AND 228 THEN 5

WHEN recency BETWEEN 229 AND 302 THEN 4

WHEN recency BETWEEN 303 AND 376 THEN 3

WHEN recency BETWEEN 377 AND 450 THEN 2

ELSE 1

END AS recency_score,

CASE

WHEN frequency <= 10 THEN 5

WHEN frequency <= 7 THEN 4

WHEN frequency <= 5 THEN 3

WHEN frequency <= 3 THEN 2

ELSE 1

END AS frequency_score,

CASE

WHEN monetary BETWEEN 104 AND 1590 THEN 1

WHEN monetary BETWEEN 1591 AND 3076 THEN 2

WHEN monetary BETWEEN 3077 AND 4562 THEN 3

WHEN monetary BETWEEN 4563 AND 6048 THEN 4

ELSE 5

END AS monetary_score

FROM customer_rfm_analysis;
5.3 Aggregate RFM Segments
sql
SELECT

rfm_segment,

COUNT(DISTINCT user_id) AS num_customers,

ROUND(COUNT(DISTINCT user_id) * 100 / SUM(COUNT(DISTINCT user_id)) OVER (), 2) AS pct_of_customer_base,

ROUND(AVG(recency), 1) AS avg_recency_days,

ROUND(AVG(frequency), 1) AS avg_frequency_orders,

ROUND(AVG(monetary), 2) AS avg_lifetime_value,

ROUND(SUM(monetary), 2) AS segment_total_revenue,

ROUND(SUM(monetary) * 100 / SUM(SUM(monetary)) OVER (), 2) AS pct_of_total_revenue,

ROUND(

    SUM(CASE WHEN gold_member = 1 THEN 1 ELSE 0 END) * 100 / NULLIF(COUNT(DISTINCT user_id), 0),

    2

) AS gold_member_adoption_pct

FROM rfm_segments

GROUP BY rfm_segment

ORDER BY segment_total_revenue DESC;
5.4 RFM Segments Results
rfm_segment	num_customers	pct_of_customer_base	avg_recency_days	avg_frequency_orders	avg_lifetime_value	segment_total_revenue	pct_of_total_revenue	gold_member_adoption_pct
Champions	737	15.54	12	5.6	4185	3084432	30.63	19.26
Loyal Customers	3103	65.42	42	3.0	1958	6075980	60.34	18.81
Potential Loyalists	903	19.04	8	1.1	1008	909988	9.03	19.71
At-Risk	245	5.17	134	2.1	1456	356720	3.54	14.29
Lost	152	3.21	267	0.8	342	51984	0.52	8.55
5.5 RFM by City (Champions)
sql
SELECT

rfm_segment,

city,

COUNT(DISTINCT user_id) AS no_of_customers,

ROUND(AVG(monetary), 2) AS avg_AOV,

ROUND(AVG(monetary), 2) AS avg_total_spend,

ROUND(SUM(monetary), 2) AS total_revenue_by_segment_city,

ROUND(SUM(monetary) * 100 / SUM(SUM(monetary)) OVER (PARTITION BY rfm_segment), 2) AS pct_revenue_within_segment,

ROUND(SUM(monetary) * 100 / SUM(SUM(monetary)) OVER (), 2) AS pct_revenue_of_company

FROM rfm_segments

GROUP BY rfm_segment, city

ORDER BY rfm_segment, total_revenue_by_segment_city DESC;
5.6 Champions by City
rfm_segment	city	no_of_customers	avg_AOV	avg_total_spend	total_revenue_by_segment_city	pct_revenue_within_segment	pct_revenue_of_company
Champions	Kolkata	138	4121.57	4121.57	568777	18.33	5.65
Champions	Delhi	130	4228.76	4228.76	549739	17.72	5.46
Champions	Chennai	128	4124.16	4124.16	527892	17.01	5.24
Champions	Hyderabad	125	4172.26	4172.26	521532	16.81	5.18
Champions	Bangalore	113	4195.34	4195.34	474073	15.28	4.71
5.7 RFM by Gold Status
sql
SELECT

rfm_segment,

gold_member,

CASE WHEN gold_member = 1 THEN 'Gold' ELSE 'Non-Gold' END AS membership,

COUNT(DISTINCT user_id) AS num_customers,

ROUND(AVG(monetary), 2) AS avg_lifetime_value,

ROUND(SUM(monetary), 2) AS total_segment_revenue

FROM rfm_segments

GROUP BY rfm_segment, gold_member

ORDER BY rfm_segment, gold_member DESC;
